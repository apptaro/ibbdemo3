<?xml version="1.0" encoding="utf-8"?>

<!-- 

iBBDemo3 is a fork of iBBDemo2 (http://ibbdemo2.googlecode.com/svn/trunk, Revision 20)
Copyright (c) 2011 apptaro

All rights reserved.
apptaro@gmail.com

...................

iBBDemo2
Copyright (c) 2010 Shaun Sullivan, Blackbaud

All rights reserved.
shaun.sullivan@blackbaud.com

Open Source License
===================
iBBDemo3 is licensed under the terms of the Open Source GPL 3.0 license. 

http://www.gnu.org/licenses/gpl.html

-->

<mx:WindowedApplication xmlns:fx="http://ns.adobe.com/mxml/2009" 
					   xmlns:s="library://ns.adobe.com/flex/spark" 
					   xmlns:mx="library://ns.adobe.com/flex/mx"
					   applicationComplete="init();"
					   showFlexChrome="false"
					   layout="absolute"
					   horizontalScrollPolicy="off"
					   verticalScrollPolicy="off"
					   width="1" height="1">
		
	<fx:Style source="ShaunAirFlex.css"/>

	<fx:Declarations>
		
		<s:Sequence id="animSafari" repeatCount="3" effectEnd="animSafari_effectEndHandler(event)" >

			<s:Animate id="ins" targets="{[imgSafari]}" duration="350" >
				<s:SimpleMotionPath property="y" valueFrom="707" valueTo="660" />
			</s:Animate>
	
			<s:Animate id="outs" targets="{[imgSafari]}" duration="75" >
				<s:SimpleMotionPath property="y" valueFrom="660" valueTo="707" />
			</s:Animate>
			
		</s:Sequence>
		
		<s:Animate id="animUp_portrait" targets="{[imgKB]}" duration="500" >
			<s:SimpleMotionPath property="alpha" valueFrom="0.0" valueTo="1.0" />
			<s:SimpleMotionPath property="y" valueFrom="1100" valueTo="800" />
			
		</s:Animate>

		<s:Animate id="animDown_portrait" targets="{[imgKB]}" duration="500">
			<s:SimpleMotionPath property="alpha" valueFrom="1.0" valueTo="0.0" />
			<s:SimpleMotionPath property="y" valueFrom="800" valueTo="1100" />
			
		</s:Animate>

		<s:Animate id="animUp_landscape" targets="{[imgKB]}" duration="500">
			<s:SimpleMotionPath property="alpha" valueFrom="0.0" valueTo="1.0" />
			<s:SimpleMotionPath property="y" valueFrom="1100" valueTo="455" />
			
		</s:Animate>
		
		<s:Animate id="animDown_landscape" targets="{[imgKB]}" duration="500">
			<s:SimpleMotionPath property="alpha" valueFrom="1.0" valueTo="0.0" />
			<s:SimpleMotionPath property="y" valueFrom="455" valueTo="1100" />
			
		</s:Animate>

		<s:Animate id="animUp_landscapeUpIphone" targets="{[imgKB]}" duration="500" >
			<s:SimpleMotionPath property="alpha" valueFrom="0.0" valueTo="1.0" />
			<s:SimpleMotionPath property="y" valueFrom="323" valueTo="162" />
			
		</s:Animate>
		
		<s:Animate id="animUp_landscapeDownIphone" targets="{[imgKB]}" duration="500">
			<s:SimpleMotionPath property="alpha" valueFrom="1.0" valueTo="0.0" />
			<s:SimpleMotionPath property="y" valueFrom="162" valueTo="323" />
			
		</s:Animate>

		<s:Animate id="anim_portraitUpIphone" targets="{[imgKB]}" duration="350" >
			<s:SimpleMotionPath property="alpha" valueFrom="0.0" valueTo="1.0" />
			<s:SimpleMotionPath property="y" valueFrom="572" valueTo="349" />
			
		</s:Animate>
		
		<s:Animate id="anim_portraitDownIphone" targets="{[imgKB]}" duration="500">
			<s:SimpleMotionPath property="alpha" valueFrom="1.0" valueTo="0.0" />
			<s:SimpleMotionPath property="y" valueFrom="349" valueTo="572" />
			
		</s:Animate>
		
		<s:Animate id="animHideAddressBarLandscape" targets="{[imgAddressBar]}" duration="250">
			<s:SimpleMotionPath property="alpha" valueFrom="1" valueTo="0" />
		</s:Animate>
		
		<s:Animate id="animShowAddressBarLandscape" targets="{[imgAddressBar]}" duration="250">
			<s:SimpleMotionPath property="alpha" valueFrom="0" valueTo="1" />
		</s:Animate>
		
		<s:Animate id="animMatteUp" targets="{[matte]}" duration="500">
			<s:SimpleMotionPath property="alpha" valueFrom="0" valueTo=".5" />
			
		</s:Animate>
		
		<s:Animate id="animMatteDown" targets="{[matte]}" duration="500">
			<s:SimpleMotionPath property="alpha" valueFrom=".5" valueTo="0" />
			
		</s:Animate>
		
		<s:Animate id="animWbIn" targets="{[wb]}" duration="500">
			<s:SimpleMotionPath property="alpha" valueFrom="0.0" valueTo="1" />
			
		</s:Animate>
		
		<s:Animate id="animWbOut" targets="{[wb]}" duration="500">
			<s:SimpleMotionPath property="alpha" valueFrom="1" valueTo="0" />
			
		</s:Animate>


	</fx:Declarations>
	
	<!-- The actual picture of the device -->
	<mx:Image id="imgBackground"  x="0" y="0" source="images/ipad_portrait.png" mouseDown="moveWindow(event);" click="startAppClick(event)"/>
	
	
	<s:BorderContainer id="matteWhite" visible="true" alpha="1.0" backgroundColor="white" x="42" y="119"  width="769" height="945">
		
		<mx:Image visible="true" id="imgBlackbaud" x="270" y="310" source="images/bblogo.jpg"/>
		<mx:Label id="lblPleaseWait" textAlign="center" x="0" y="420" fontFamily="Arial" fontSize="20" width="763" text="Please Wait..."/>
		
	</s:BorderContainer>
	
		
	<!-- The picture of the addresbar -->
	<mx:Image id="imgAddressBar"  x="42" y="60" height="89" source=""/>

	<mx:HTML alpha="0.0" id="wb" verticalScrollPolicy="off" horizontalScrollPolicy="off" x="42" y="149"  width="769" height="915" mouseMove="wbMouseMove(event)" />
	
	
	<!-- Invisible image overlayed over the springboard so we can trap the click -->
	<s:BorderContainer id="btnHome" borderAlpha="0.0" click="bClick(event)" x="381" y="1071" width="96" height="30" backgroundAlpha="0.0"></s:BorderContainer>
	<mx:TextInput id="txtAddressPort" fontSize="14" focusColor="white" focusOut="txtAddressPort_focusOutHandler(event)" focusIn="txtAddressPort_focusInHandler(event)" click="txtAddressPort_clickHandler(event)" enter="nav(event)" borderStyle="none" x="282" y="85" width="323" height="25" contentBackgroundAlpha="1.0"  focusRoundedCorners="tr tl br bl"/> 

	<mx:TextInput id="txtGoogle" focusColor="white" focusOut="txtGoogle_focusOutHandler(event)" focusIn="txtGoogle_focusInHandler(event)" click="txtGoogle_clickHandler(event)" enter="googleSearch(event)" borderStyle="none" x="623" y="86" width="143" height="22" contentBackgroundColor="white" focusRoundedCorners="tr tl br bl" /> 

	<mx:Image id="imgDelete" click="imgDelete_clickHandler(event)" x="582" y="87" visible="false" source="images/adel.png" /> 
	<mx:Image id="imgRefresh" click="imgRefresh_clickHandler(event)" x="582" y="87" visible="false" source="images/arefresh.png" /> 

	<mx:Image id="imgKB" x="42" y="1120" source=""/>
	
	<s:BorderContainer id="matte" visible="false" alpha="0.0" backgroundColor="black" x="0" y="119"  width="769" height="685"/>
	
	<s:BorderContainer click="btnBack_clickHandler(event)" x="43" y="76" width="49" height="44" borderAlpha="0.0" backgroundAlpha="0.0" id="btnBack"/>
	
	<mx:Image id="imgSafari" alpha="1" x="515" y="707" source="images/safari.png" click="startAppClick(event)"/>
	
	<s:BorderContainer backgroundColor="red" id="topOfPhone" x="0" y="0" width="{imgBackground.width}" height="45" click="topOfPhone_clickHandler(event)" borderAlpha="0.0" backgroundAlpha="0.0" mouseOver="topOfPhone_mouseOverHandler(event)" mouseMove="topOfPhoneMouseMove(event)" mouseDown="moveWindow(event);"   />
	
	<fx:Script>
		<![CDATA[
			
			// For dynamic update support
			import air.update.events.UpdateEvent; 
			import air.update.ApplicationUpdaterUI;
			
			import flash.net.navigateToURL;
			import flash.utils.setTimeout;
			
			import mx.events.EffectEvent;
			import mx.messaging.channels.StreamingAMFChannel;
			
			import spark.components.ToggleButton;
			
			
			private var _origLogoX:int;
			private var _supportFlash:Boolean = false;
			
			private var _userForcedAddressBar:Boolean = false;
			private var _host:HTMLHostImplementation = new HTMLHostImplementation();
			private var _sAddr:String = "";
			private var _grabURLFromBack:Boolean = false;
			private var _kbVisible:Boolean = false;
			private var _userEnteringText:Boolean = false;
			private var _viewportMetaTag:ViewportMetaTag;

			
			private const IPAD_PORTRAIT:int = 1;
			private const IPAD_LANDSCAPE:int = 2;
			private const IPHONE_PORTRAIT:int = 3;
			private const IPHONE_LANDSCAPE:int = 4;
			
			// The top position of the keyboard picture when it is visible
			private var _kbyWhenVisible:int = 0;
			
			// Tracks which of the 4 device/mode combinations we are currently in
			// default is the iPad in portrait mode
			private var _mode:int = IPAD_PORTRAIT;
			
			/* Uncomment this to hookup dynamic update support 
			private var updater:ApplicationUpdaterUI = new ApplicationUpdaterUI();
			*/
			
			//////////////////////////////////
			// Entry Point for the app
			/////////////////////////////////
			
			private function init():void
			{	
				
				/* Uncomment this to hookup dynamic update support 
				
				updater.configurationFile = new File("app:/updaterConfig.xml"); 
				updater.addEventListener(UpdateEvent.INITIALIZED, updaterInitialized);
				updater.initialize();
				
				*/
				
				// Wire up so we can hook some lower level stuff
				// probably better to use events, but this works
				_host.setLocationCallBack(this.locationChanged);
				
				registerGlobalKeyHandler();
				
				// Always start by default in iPad Portrait, that way we don't need to do 4 startup screens
				_mode = IPAD_LANDSCAPE;
				_mode = IPHONE_PORTRAIT; // change defaults to iphone portrait
				
				// Fires when HTML document is fully loaded and initialized
				wb.addEventListener(Event.COMPLETE, comp);
				
				setUserAgent();
				
				// We are using a custom implementation of HTMLHost
				wb.htmlHost = _host;
				
				setDeviceDefaults();
				
				// Defer display until we've been properly centered
				this.stage.nativeWindow.visible = true;
				
				// We'll start on a fake iPad launch screen 
				hideBrowser();
				
			}
		
			/* Uncomment this to hookup dynamic update support 
				
			private function updaterInitialized(event:UpdateEvent):void
			{ 
				trace("in updaterInitialized!");
				trace(event.target.isFirstRun); 
				trace(event.target.previousVersion);
				trace(event.target.currentVersion);
				
				// Uncommenting the next line would force an update check 
				//updater.checkNow();
			}
			*/
			
			// Callback from our custom HTMLHostImplementation, user clicked on a link or something to nav
			public function locationChanged(locationURL:String):void
			{
				_sAddr = locationURL;
				
				animWbOut.play();
				wb.visible=false;
				
			}
			
			private function startApp():void
			{
				
				showBrowser();
				
				// Load our inital startup page into the browser
				_sAddr = "app:/about.html";
				navigateToAddress();
				
			}
			
			private function showBrowser():void
			{
				
				lblPleaseWait.visible=true;
				imgBlackbaud.visible=true;
				matteWhite.visible=true;
				
				imgSafari.visible = false;
				wb.alpha = 0;
				wb.visible = true;
				imgAddressBar.visible = true;
				matteWhite.visible = true;
				
				animWbIn.play();
				
			}
			
			private function hideBrowser():void
			{
				
				lblPleaseWait.visible=false;
				imgBlackbaud.visible=false;
				matteWhite.visible=false;
					
				wb.visible = false;
				imgAddressBar.visible = false;
				matteWhite.visible = false;
				imgSafari.visible = true;
				//animSafari.play();
				
				setTimeout(startApp, 1000);
				
			}
			// This is analagous to DocumentComplete
			private function comp(event:Object):void
			{
				
				// If they hit the back button we need to stay in sync with what URL is currently loaded on the page
				if (_grabURLFromBack) 
				{
					_grabURLFromBack = false;
					_sAddr = wb.location; 
				}
				
				txtAddressPort.text = wb.location;
				
				var index:int = _sAddr.indexOf( "app:/about.html" );
				
				// When we are on one of our hosted pages we want navigation to external 
				// links to happen via the operating system's browser as opposed to our browser component
				if (index != -1) 
				{
					wb.htmlLoader.navigateInSystemBrowser = true;
				}
				else
				{
					wb.htmlLoader.navigateInSystemBrowser = false;
				}
				
				// Once we nav, like the iPad, we slide the HTML control up a bit
				switch (_mode)
				{
					
					case IPAD_PORTRAIT:
				
						wb.top = 149 - 30;
						wb.height = 915 + 30;
						break;
					
					case IPAD_LANDSCAPE:
					
						wb.top = 149 - 30;
						wb.height = 660 + 30;
						break;
					
					// On the iPhone, we hide the address bar
					case IPHONE_PORTRAIT:
						
						hideAddressBar();
						break;
					
						
					case IPHONE_LANDSCAPE:
						
						hideAddressBar();
						break;
					
				}
				
				// Work around for pages with framesets firing multiple completes.
				if (_kbVisible)
					slideDownKb();
				
				// Scale the content
				_viewportMetaTag = ViewportMetaTag.parse(_host.getHTMLLoader().window.document);
				scaleContent();
				
				sanitize();
				
				// Fade our browser in smoothly after we have rescaled the content
				wb.visible = true;
				wb.setFocus();	
				animWbIn.play();
				
				// Sometimes we re-use the caption when doing stuff like toggling Flash support
				lblPleaseWait.text = "Please Wait...";
				
				if (imgBlackbaud.source.toString().toLowerCase() != "images/bblogo.jpg")
				{	
					imgBlackbaud.x = _origLogoX;
					imgBlackbaud.source = "images/bblogo.jpg";
				}	
			}

			
			// When the user hits enter in the address control
			private function nav(event:Object):void
			{
				slideDownKb();
				_sAddr = txtAddressPort.text;	
				
				var index:int = _sAddr.indexOf( "http://" );
				
				if (index == -1)
				{
					index = _sAddr.indexOf( "https://" );
				}
						
				if (index == -1) 
				{
					_sAddr = "http://" + _sAddr;
				}		
				
				navigateToAddress();
			}
			
			private function navigateToAddress():void
			{
				// Hide the broser via a fade animation and give it a half a second to play 
				// before doing the navigation
				animWbOut.play();
				wb.visible=false;
				setTimeout( deferNav, 1);
			}
			
			private function deferNav():void
			{
				wb.location= _sAddr;
			}
	
			// Trap click on invisible image we have overlayed the springboard 
			// allows the user to quickly exit the app
			private function bClick(event:MouseEvent):void
			{
				//doPortrait();
				
				
				exit();
			}

			// So the user can drag our custom chrome window around
			// by dragging the ipad skin (outside the browser component)
			private function moveWindow(event:MouseEvent):void 
			{
				this.stage.nativeWindow.startMove();
			}
			
			private function centerOnScreen():void
			{
				
				var centerX:Number = Screen.mainScreen.bounds.width / 2; 
				var centerY:Number = Screen.mainScreen.bounds.height / 2; 
				this.stage.nativeWindow.x = centerX - (this.stage.nativeWindow.width / 2); 
				this.stage.nativeWindow.y = centerY - (this.stage.nativeWindow.height / 2);
				
			}
			
			// User clicks in the address bar
			protected function txtAddressPort_clickHandler(event:MouseEvent):void
			{
				
				txtAddressPort.setSelection(0, txtAddressPort.text.length);
						
				if (imgKB.y > _kbyWhenVisible)
					slideUpKb();
				
			}

			// Address bar gets focus some other way
			protected function txtAddressPort_focusInHandler(event:FocusEvent):void
			{
				_userEnteringText = true;
				imgDelete.visible = true;
				slideUpKb();
			}

			// Give the illusion of the iPad by sliding up a fake keyboard and simming 
			// the browser client area of the window
			private function slideUpKb():void
			{
				if (_kbVisible)
					return;
				
				_kbVisible = true;
				
				wb.htmlLoader.navigateInSystemBrowser = false;
					
				imgRefresh.visible = false;
				
				switch (_mode)
				{
					case IPAD_PORTRAIT:
						
						wb.y += 230;
						wb.height -= 30;

						animUp_portrait.play();
						matte.visible = true;
						animMatteUp.play();
						break;
								
					case IPAD_LANDSCAPE:
						
						wb.y += 30;
						wb.height -= 30;

						animUp_landscape.play();
						matte.visible = true;
						animMatteUp.play();
						break;
					
					case IPHONE_PORTRAIT:
						
						anim_portraitUpIphone.play();
						matte.visible = true;
						animMatteUp.play();
						break;
						
					case IPHONE_LANDSCAPE:
						
						animUp_landscapeUpIphone.play();
						matte.visible = true;
						animMatteUp.play();
						break;
						
						
				}

			}

			private function slideDownKb():void
			{
				if (!_kbVisible)
					return;
					
				_kbVisible = false;
				
				switch (_mode)
				{
					case IPAD_PORTRAIT:
						
						wb.y -= 30;
						wb.height += 30;
						
						animDown_portrait.play();
						animMatteDown.play();	
						matte.visible = false;
						break;
					
					case IPAD_LANDSCAPE:

						wb.y -= 30;
						wb.height += 30;

						animDown_landscape.play();
						animMatteDown.play();	
						matte.visible = false;
						break;
					
					case IPHONE_PORTRAIT:
						
						anim_portraitDownIphone.play();
						animMatteDown.play();	
						matte.visible = false;
						break;
						
					case IPHONE_LANDSCAPE:
						
						animUp_landscapeDownIphone.play();
						animMatteDown.play();	
						matte.visible = false;
						break;
						
						//animDown_portraitIPhone
						
				}
			}

			protected function txtAddressPort_focusOutHandler(event:FocusEvent):void
			{
				_userEnteringText = false;
				imgDelete.visible = false;
			}


			protected function imgDelete_clickHandler(event:MouseEvent):void
			{
				txtAddressPort.text="";
			}

			protected function imgRefresh_clickHandler(event:MouseEvent):void
			{
				//wb.htmlLoader.reload();
				navigateToAddress();
			}

			protected function txtGoogle_clickHandler(event:MouseEvent):void
			{
				if (imgKB.y > _kbyWhenVisible)
					slideUpKb();
				
			}
			
			protected function txtGoogle_focusInHandler(event:FocusEvent):void
			{
				_userEnteringText = true;
				imgDelete.visible = true;
				slideUpKb();
			}

			protected function txtGoogle_focusOutHandler(event:FocusEvent):void
			{
				_userEnteringText = false;
			}

			private function googleSearch(event:Object):void
			{
				slideDownKb();
				_sAddr = "http://www.google.com/search?&q=" + txtGoogle.text;
				navigateToAddress();
			}
	
			protected function btnBack_clickHandler(event:MouseEvent):void
			{
				//slideDownKb();
				
				if (wb.historyLength > 0)
				{	
					_grabURLFromBack = true;
					wb.historyBack();
				}
			}

			private function setUserAgent():void
			{
				
				// Set the User Agent String so that sites/apps think they are being summoned from the 
				// device we are currently simulating

				switch (_mode) 
				{
					case IPAD_PORTRAIT:
					case IPAD_LANDSCAPE:
						wb.userAgent = "Mozilla/5.0 (iPad; U; CPU OS 3_2 like Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) Version/4.0.4 Mobile/7B334b Safari/531.21.10";
						//wb.userAgent = "Shaun";			
						break;
					
					case IPHONE_PORTRAIT:
					case IPHONE_LANDSCAPE:
						
						// Not sure if it is important to use specific iPhone device user agents (e.g 3GS, touch, iPhone 4)?
						wb.userAgent = "Mozilla/5.0 (iPhone; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3B48b Safari/419.3";
						break;
					
						
				}
				
			}
			
			// Dymaically scale the content appropriately
			private function scaleContent():void
			{
				
				var loader:HTMLLoader;
				var bodyTag:Object;
				var deviceWidth:Number;
				var deviceHeight:Number;
				var defaultZoom:Number;
				
				// Sometimes we hit strange situations where we can't do dom manipulations
				// Since it is non-fatal, we'll just eat it and not scale the content
				try 
				{
					// Access the dom
					// We are going to use the CSS3 .zoom property for our fake scale
					loader = _host.getHTMLLoader();
					bodyTag = loader.window.document.getElementsByTagName("body")[0];
						
				}
				 catch (errObject:Error) 
				{
					return;
				}
				
				// Another failsafe, make sure we were able to get a reference to the body tag
				if (bodyTag == null)
					return;
					
				switch (_mode) 
				{
					case IPAD_PORTRAIT:
						deviceWidth = 769;
						deviceHeight = 915;
						defaultZoom = .75;
						break;
					
					case IPAD_LANDSCAPE:
						deviceWidth = 1026;
						deviceHeight = 660;
						defaultZoom = 1;
						break;
					
					case IPHONE_PORTRAIT:
						deviceWidth = 318;
						deviceHeight = 357;
						defaultZoom = 1;
						break;
					
					case IPHONE_LANDSCAPE:
						deviceWidth = 480;
						deviceHeight = 211;
						defaultZoom = 1;
						break;
				}
				
				if (!isNaN(_viewportMetaTag.initialScale)) {
					defaultZoom = _viewportMetaTag.initialScale;
				} else if (_viewportMetaTag.deviceWidth) {
					defaultZoom = 1;
				} else if (!isNaN(_viewportMetaTag.width)) {
					defaultZoom = deviceWidth / _viewportMetaTag.width;
				}
				if (!isNaN(_viewportMetaTag.maximumScale)) {
					defaultZoom = (defaultZoom > _viewportMetaTag.maximumScale) ? _viewportMetaTag.maximumScale : defaultZoom;
				}
				if (!isNaN(_viewportMetaTag.minimumScale)) {
					defaultZoom = (defaultZoom < _viewportMetaTag.minimumScale) ? _viewportMetaTag.minimumScale : defaultZoom;
				}
				
				bodyTag.style.zoom = defaultZoom;
			}

			private function scaleContentAbs(scaleVal:Number):void
			{
				
				var loader:HTMLLoader;
				var bodyTag:Object;
				
				// Sometimes we hit strange situations where we can't do dom manipulations
				// Since it is non-fatal, we'll just eat it and not scale the content
				try 
				{
					// Access the dom
					// We are going to use the CSS3 .zoom property for our fake scale
					loader = _host.getHTMLLoader();
					bodyTag = loader.window.document.getElementsByTagName("body")[0];
					
				}
				 catch (errObject:Error) 
				{
					return;
				}
				
				// Another failsafe, make sure we were able to get a reference to the body tag
				if (bodyTag == null)
					return;
				
				var curZoom:Number = parseFloat(bodyTag.style.zoom);
				
				// With iPhone we don't set a default scale, so if this is the first 
				// time we are trying to change the zoom we need to set an initial zoom 
				// style on the body tag so we can subsequently modify it
				if (isNaN(curZoom)) 
				{
					bodyTag.style.zoom = 1;
					curZoom = parseFloat(bodyTag.style.zoom);
				}
				
				if (_viewportMetaTag.userScalable) {
					curZoom += scaleVal;
				}
				
				if (!isNaN(_viewportMetaTag.maximumScale)) {
					curZoom = (curZoom > _viewportMetaTag.maximumScale) ? _viewportMetaTag.maximumScale : curZoom;
				}
				if (!isNaN(_viewportMetaTag.minimumScale)) {
					curZoom = (curZoom < _viewportMetaTag.minimumScale) ? _viewportMetaTag.minimumScale : curZoom;
				}
				
				bodyTag.style.zoom = curZoom;
				
				trace("bodyTag.style.zoom = " + bodyTag.style.zoom);
				
			}

			// Resize the main window based on what we are simulating
			private function setHostWindowDimensions():void
			{
	
				switch (_mode) 
				{
					case IPAD_PORTRAIT:
						this.stage.nativeWindow.width = 875;
						this.stage.nativeWindow.height = 1110;

						break;
					
					case IPAD_LANDSCAPE:

						this.stage.nativeWindow.width = 1108;
						this.stage.nativeWindow.height = 852;
	
						break;
					
					case IPHONE_PORTRAIT:
						this.stage.nativeWindow.width = 386;
						this.stage.nativeWindow.height = 742;
						break;
							
					
					case IPHONE_LANDSCAPE:
				
						this.stage.nativeWindow.width = 731;
						this.stage.nativeWindow.height = 386;
						
						break;
					
				}
				
				
			}
		
			private function setDeviceImage():void
			{
				switch (_mode) 
				{
					case IPAD_PORTRAIT:
						
						// device pic
						imgBackground.source = "images/ipad_portrait.png";
						// Address bar pic
						imgAddressBar.source = "images/portaddress_only.png";
						// Keyboard pic
						imgKB.source = "images/portkb_only.png";
						break;
					
					case IPAD_LANDSCAPE:
						
						imgBackground.source = "images/ipad_landscape.png";
						imgAddressBar.source = "images/lsaddress_only.png";
						imgKB.source = "images/lskb_only.png";
						break;
					
					case IPHONE_PORTRAIT:
						
						imgBackground.source = "images/iphone_chrome_portrait.png";
						imgAddressBar.source = "images/iphone_address_portrait.png";
						imgKB.source = "images/iphone_kb_portrait.png";
						break;
					
					case IPHONE_LANDSCAPE:
					
						imgBackground.source = "images/iphone_chrome_landscape.png";
						imgAddressBar.source = "images/iphone_address_ls.png";
						imgKB.source = "images/iphone_kb_landscape.png";
						
						break;
					
				}
			
			}
			
			// Adust all the component dimensions and positions based on the device
			// This feels a little brute-force, there is probably a better way to do it 
			// but I am new to Flex
			private function positionInputFields():void
			{

				switch (_mode) 
				{
					case IPAD_PORTRAIT:
						
						// We don't do the show address bar on mouse over top of phone effect for iPad
						topOfPhone.height = 0;
						
						// The y position the keyboard will slide to when it is visible
						_kbyWhenVisible = 800;
						
						// Browser address bar
						txtAddressPort.x = 282;
						txtAddressPort.y = 85;
						txtAddressPort.height = 23; 
						txtAddressPort.width = 323;
				
						// Google search field	
						txtGoogle.x = 623;
						txtGoogle.y = 86;
						txtGoogle.height = 22; 
						txtGoogle.width = 143;

						// delete icon that shows up in the address bar text field
						imgDelete.x = 580;
						imgDelete.y = 87;
						
						imgSafari.x = 400;
						imgSafari.y = 800;
						
						// refresh icon that shows up in the address bar text field
						imgRefresh.x = 582;
						imgRefresh.y = 87;
						
						// The invisible button over the springboard
						btnHome.x = 381;
						btnHome.y = 1071;
						btnHome.width = 96;
						btnHome.height = 30;
						
						// The matte we use to give the dimming effect when the keyboard slides up
						matte.x = 42; 
						matte.y = 119;
						matte.width = 769;
						matte.height = 685;
						
						// White matte when we show the "Loading.." screen
						matteWhite.x = 42; 
						matteWhite.y = 119;
						matteWhite.width = 769;
						matteWhite.height = 945;
						
						// Blackbaud logo on the loading screen
						imgBlackbaud.x = 250; 
						imgBlackbaud.y = 370;
						
						// Please wait text label
						lblPleaseWait.x = 0;
						lblPleaseWait.y = 490;
						lblPleaseWait.width = 769;
						
						// The web browser window
						wb.x = 42; 
						wb.y = 119;
						wb.width = 769;
						wb.height = 915;
						
						// The actual picture of the device
						imgBackground.x = 0;
						imgBackground.y = 0;
						
						// Address bar of the browser
						imgAddressBar.x = 42;
						imgAddressBar.top = 60;
						// Address bar is always visible on the iPad
						imgAddressBar.visible = true;
						//imgAddressBar.alpha = 1;
						
						// Picture of the device keyboard that we show when text fields get focus
						imgKB.x = 42;
						imgKB.y = 1120;
						
						break;
					
					case IPAD_LANDSCAPE:

						// We don't do the show address bar on mouse over top of phone effect for iPad
						topOfPhone.height = 0;
						
						// The y position the keyboard will slide to when it is visible
						_kbyWhenVisible = 455;
							
						// Browser address bar
						txtAddressPort.x = 284;
						txtAddressPort.y = 85;
						txtAddressPort.height = 23; 
						txtAddressPort.width = 450;
						
						// Google search field	
						txtGoogle.x = 786;
						txtGoogle.y = 86;
						txtGoogle.height = 20; 
						txtGoogle.width = 230;
						
						// delete icon that shows up in the address bar text field
						imgDelete.x = 744;
						imgDelete.y = 85;
						
						imgSafari.x = 515;
						imgSafari.y = 707;
						
						// refresh icon that shows up in the address bar text field
						imgRefresh.x = 744;
						imgRefresh.y = 85;
						
						// The invisible button over the springboard
						btnHome.x = 1075;
						btnHome.y = 406;
						btnHome.width = 96;
						btnHome.height = 30;
					
						// The web browser window
						wb.x = 42; 
						wb.y = 119;
						wb.width = 1026;
						wb.height = 660;
						
						
						// The matte we use to give the dimming effect when the keyboard slides up
						matte.x = 42; 
						matte.y = 119;
						matte.width = 1026;
						matte.height = 340;
						
						// White matte when we show the "Loading.." screen
						matteWhite.x = 42; 
						matteWhite.y = 119;
						matteWhite.width = 1026;
						matteWhite.height = 690;
						
						// Blackbaud logo on the loading screen
						imgBlackbaud.x = 370; 
						imgBlackbaud.y = 270;
						
						// Please wait text label
						lblPleaseWait.x = 0;
						lblPleaseWait.y = 380;
						lblPleaseWait.width = 1026;
						
						
						// The actual picture of the device
						imgBackground.x = 0;
						imgBackground.y = 0;
						
						// Address bar of the browser
						imgAddressBar.x = 42;
						imgAddressBar.top = 60;
						
						// Address bar is always visible on the iPad
						imgAddressBar.visible = true;
						//imgAddressBar.alpha = 1;
						
						
						// Picture of the device keyboard that we show when text fields get focus
						imgKB.x = 42;
						imgKB.y = 1120;
						
							
						break;
					
					case IPHONE_PORTRAIT:
					
						// The y position the keyboard will slide to when it is visible
						_kbyWhenVisible = 349;
						
						
						topOfPhone.height = 125;
						
						
						// Position our invisible button to trap when the user hits the back button in the iPhone chrome
						btnBack.x = 171;
						btnBack.y = 639;
						
						// Browser address bar
						txtAddressPort.x = 45;
						txtAddressPort.y = 177;
						txtAddressPort.height = 23; 
						txtAddressPort.width = 155;
						
						// Google search field	
						txtGoogle.x = 260;
						txtGoogle.y = 177;
						txtGoogle.height = 22; 
						txtGoogle.width = 74;
						
						// delete icon that shows up in the address bar text field
						imgDelete.x = 209;
						imgDelete.y = 178;
						
						// refresh icon that shows up in the address bar text field
						imgRefresh.x = 209;
						imgRefresh.y = 178;
						
						// The invisible button over the springboard
						btnHome.x = 163;
						btnHome.y = 635;
						
						btnHome.width = 96;
						btnHome.height = 70;
						
						// The matte we use to give the dimming effect when the keyboard slides up
						matte.x = 33; 
						matte.y = 210;
						matte.width = 327;
						matte.height = 140;
						
						// White matte when we show the "Loading.." screen
						matteWhite.x = 32; 
						matteWhite.y = 210;
						matteWhite.width = 320;
						matteWhite.height = 357;
						
						// Blackbaud logo on the loading screen
						imgBlackbaud.x = 23; 
						imgBlackbaud.y = 100;
						
						// Please wait text label
						lblPleaseWait.x = 0;
						lblPleaseWait.y = 190;
						lblPleaseWait.width = 318;
						
						// The web browser window
						wb.x = 34; 
						wb.y = 212;
						wb.width = 318;
						wb.height = 357;
						
						// The actual picture of the device
						imgBackground.x = 0;
						imgBackground.y = 0;
						
						// Address bar of the browser
						imgAddressBar.x = 33;
						imgAddressBar.top = 150;
						//imgAddressBar.height = 59;
						//imgAddressBar.width = 330;
						
						
						// Picture of the device keyboard that we show when text fields get focus
						imgKB.x = 33;
						imgKB.y = 745;		// Starts off screen
						//imgKB.visible = false;
						
						break;

					
					case IPHONE_LANDSCAPE:

						
						topOfPhone.height = 45;
						
						// The y position the keyboard will slide to when it is visible
						_kbyWhenVisible = 162;
						
						// Position our invisible button to trap when the user hits the back button in the iPhone chrome
						btnBack.x = 144;
						btnBack.y = 328;
						
						// Browser address bar
						txtAddressPort.x = 142;
						txtAddressPort.y = 78;
						txtAddressPort.height = 23; 
						txtAddressPort.width = 255;
						
						// Google search field	
						txtGoogle.x = 455;
						txtGoogle.y = 80;
						txtGoogle.height = 22; 
						txtGoogle.width = 135;
						
						// delete icon that shows up in the address bar text field
						imgDelete.x = 410;
						imgDelete.y = 79;
						
						imgSafari.x = 400;
						imgSafari.y = 800;
						
						// refresh icon that shows up in the address bar text field
						imgRefresh.x = 410;
						imgRefresh.y = 79;
						
						// The invisible button over the springboard
						btnHome.x = 636;
						btnHome.y = 170;
						btnHome.width = 96;
						btnHome.height = 30;
						
						// The matte we use to give the dimming effect when the keyboard slides up
						matte.x = 131; 
						matte.y = 112;
						matte.width = 481;
						matte.height = 52;
						
						// White matte when we show the "Loading.." screen
						matteWhite.x = 131; 
						matteWhite.y = 52;
						matteWhite.width = 481;
						matteWhite.height = 269;
					
						// Blackbaud logo on the loading screen
						imgBlackbaud.x = 96; 
						imgBlackbaud.y = 70;
						
						// Please wait text label
						lblPleaseWait.x = 0;
						lblPleaseWait.y = 160;
						lblPleaseWait.width = 475;
						
						// The web browser window
						wb.x = 131; 
						wb.top = 97;
						wb.width = 480;
						wb.height = 211;
						
						// The actual picture of the device
						imgBackground.x = 0;
						imgBackground.y = 0;
						
						// Address bar of the browser
						imgAddressBar.x = 131;
						imgAddressBar.top = 52;
						
						// Picture of the device keyboard that we show when text fields get focus
						imgKB.x = 131;
						imgKB.y = 425;		// Starts off screen
						
						break;

				}
			}
			
			// Fired after our little bounce animation intro completes
			protected function animSafari_effectEndHandler(event:EffectEvent):void
			{
				startApp();				
			}

			// When the	
			protected function toggleOrientation():void
			{
				switch (_mode)
				{
					case IPAD_LANDSCAPE:
						_mode = IPAD_PORTRAIT;
						break;
					
					case IPAD_PORTRAIT:
						_mode = IPAD_LANDSCAPE;
						break;
						
					case IPHONE_PORTRAIT:
						_mode = IPHONE_LANDSCAPE;
						break;
							
					case IPHONE_LANDSCAPE:
						_mode = IPHONE_PORTRAIT;
						break;
					
						
				}
				
				setDeviceDefaults();
				
				// reload the current page
				if (_sAddr.length > 0)
					navigateToAddress();
			}
			
			private function setDeviceDefaults():void
			{
				setHostWindowDimensions();
				
				setDeviceImage();
				
				positionInputFields();
				
				centerOnScreen();
			}

			public function registerGlobalKeyHandler() :void
			{
				stage.addEventListener(KeyboardEvent.KEY_DOWN, handleKeyDown);
			}
			
			// Global (Application-wide) keyboard handler
			public function handleKeyDown(event:KeyboardEvent) :void
			{
				
				var bDoRefresh:Boolean = false;
				
				// CTRL-T Test mode
				if (event.ctrlKey && (event.keyCode == Keyboard.T))
				{
					_sAddr = "app:/test.html";
					navigateToAddress();
					return;
				}	
					
				// Toggle Flash Support CTRL-SHIFT-F
				if (event.ctrlKey && event.shiftKey && (event.keyCode == Keyboard.F))
				{
					if (_supportFlash)
					{
						_supportFlash = false;
						lblPleaseWait.text = "Disabling Adobe Flash...";
					}
					else
					{	
						lblPleaseWait.text = "Enabling Adobe Flash...";
						_supportFlash = true;
					}
					
					// Need to re-load
					_origLogoX = imgBlackbaud.x;
					imgBlackbaud.source = "/images/flash.png";
					imgBlackbaud.x += 80;

					navigateToAddress();
					return;
				}	
				
				// By convention, refresh on the Mac is COMMAND-R and on Windows it is F5
				if (Mac() && event.commandKey)
				{
					if (event.keyCode == Keyboard.R)
					{
						bDoRefresh = true;
					}
					
					// COMMAND-L to set focus to address bar on Mac if it is visible
					if (event.keyCode == Keyboard.L)
					{
						
						if (imgAddressBar.alpha == 1)
						{
							txtAddressPort.setFocus();
							if (txtAddressPort.text.length > 0)
								txtAddressPort.setSelection(0, txtAddressPort.text.length);
							
							return;
						}
					}
						 
				}
				
				if (Windows() && (event.keyCode == Keyboard.F5))
				{
					bDoRefresh=true;
				}
			
				// ALT-D to set focus to Address Bar on Windows if it is visible
				if (Windows() && event.altKey && event.keyCode == Keyboard.D && imgAddressBar.alpha == 1)
				{
					txtAddressPort.setFocus();
					
					if (txtAddressPort.text.length > 0)
						txtAddressPort.setSelection(0, txtAddressPort.text.length);
					
					return;	
				}
					
				if (bDoRefresh && (_sAddr.length > 0))
				{
					navigateToAddress();
					return;
				}

				// Switch between devices with ctrl-1 ctrl-2
				if (event.ctrlKey)
				{
					
					var bProc:Boolean = false;
					
					//
					// CTRL-D Force-Toggles the address bar on the iPhone
					// 
					
					if (event.keyCode == Keyboard.D)
					{
						if (iPhoneMode())
						{
							if (imgAddressBar.alpha == 1)
							{
								_userForcedAddressBar = false;
								hideAddressBar();
								return;
							}	
							else
							{
								_userForcedAddressBar = true;
								showAddressBar();
								return;
							}		
							
						}	
					}	
					
					if (event.keyCode == Keyboard.EQUAL) 
					{
						event.preventDefault();
						scaleContentAbs(.10);
						return;
					}	
					
					if (event.keyCode == Keyboard.MINUS) 
					{
						event.preventDefault();
						scaleContentAbs(-.10);
						return;
					}
					
					if ((event.keyCode == Keyboard.RIGHT) || event.keyCode == Keyboard.LEFT)
					{
						event.preventDefault();
						toggleOrientation();
						return;
					}
					
					// CTRL-1 for iPAD
					if (event.keyCode == Keyboard.NUMBER_1)
					{
						
						if (_mode == IPHONE_LANDSCAPE)
						{
							_mode = IPAD_LANDSCAPE;
							showAddressBar();
							bProc = true;
						}
						else if (_mode == IPHONE_PORTRAIT)
						{
							_mode = IPAD_PORTRAIT;
							showAddressBar();
							bProc = true;
						}
						
					}	
							
					// CTRL-2 for iPhone
					if (event.keyCode == Keyboard.NUMBER_2)
					{	
				
						if (_mode == IPAD_LANDSCAPE)
						{
							matte.visible = false;
							_mode = IPHONE_LANDSCAPE;
							bProc = true;
						}
						else if (_mode == IPAD_PORTRAIT)
						{
							matte.visible = false;
							_mode = IPHONE_PORTRAIT;
							bProc = true;
						}
						else
							return;

					}
					
					if (bProc) 
					{
						event.preventDefault();
						
						setUserAgent();
						
						//trace(imgAddressBar.alpha);
						//trace(imgAddressBar.visible);
						
						setDeviceDefaults();
						
						if (!iPhoneMode()) 
						{
							imgAddressBar.alpha = 1;
							imgAddressBar.visible = true;
								
						}
						// reload the current page
						if (_sAddr.length > 0)
							navigateToAddress();
						
					}
								
				}	
				
			}

			private function showAddressBar():void
			{
				animShowAddressBarLandscape.play();
				txtAddressPort.visible = true;
				txtGoogle.visible = true;
				
				if (iPhoneMode()) 
				{
					if (_mode == IPHONE_LANDSCAPE)
					{
						wb.height = 210;
						wb.top = 114;
					}
					else
					{
						wb.height = 355;
						wb.top = 212;
					}
				}
				
				if (_userEnteringText)
				{
					imgDelete.visible = true;
					imgRefresh.visible = false;
				}
				else
				{
					imgDelete.visible = false;
					imgRefresh.visible = true;
				}
			}

			private function hideAddressBar():void
			{
				if (iPhoneMode() && _userForcedAddressBar)  
					return;
				
				if (!iPhoneMode())
					return;
				
				if (iPhoneMode())
				{
					if (_mode == IPHONE_LANDSCAPE)
					{
						wb.top = 52;
						wb.height = 320 - 52;
					}
					else
					{
						wb.top = imgAddressBar.top;
						wb.height = 420; 
					}
				}
				
				txtAddressPort.visible = false;
				txtGoogle.visible = false;
				
				imgDelete.visible = false;
				imgRefresh.visible = false;
				
				animHideAddressBarLandscape.play();
				
			}
				
			// In iPhone mode, when the user mouses over the top of the phone chrome, show the address bar
			protected function topOfPhoneMouseMove(event:MouseEvent):void
			{
				if (iPhoneMode())
				{
					if (imgAddressBar.alpha == 0)
						showAddressBar();
					
				}
			}
			
			
			private function iPhoneMode():Boolean
			{
				return (_mode == IPHONE_LANDSCAPE || _mode == IPHONE_PORTRAIT) ? true : false;
				
			}

			// If the address bar is visible and we are in iPhone mode, hide it if the 
			// user mouses down into the main content area of the page, leaving a little dead are at the 
			// top of the page to avoid dismissing it if they interacting with the address bar
			protected function wbMouseMove(event:MouseEvent):void
			{
				//trace("imgAddressBar.alpha = " + imgAddressBar.alpha);
				if (_userForcedAddressBar)
					return;
				
				if (iPhoneMode() && imgAddressBar.alpha != 0)
				{
					if (_mode == IPHONE_LANDSCAPE)
					{	
						//trace("event.stageY = " + event.stageY);
						if (event.stageY > 280)
							hideAddressBar();
					}
					else
					{
						if (event.stageY > 320)
							hideAddressBar();
					}	
				}
				
			}

			// In order for the best illusion in a presentation, when we start the app, we
			// show a faux iPad background, and click by the user starts the web browser on our welcome page
			protected function startAppClick(event:MouseEvent):void
			{
				if (!wb.visible)
					startApp();
			}


			protected function topOfPhone_mouseOverHandler(event:MouseEvent):void
			{
				if (iPhoneMode())
				{
					if (imgAddressBar.alpha == 0)
						showAddressBar();
					
				}
			}

			
			// Clicking on the top of the phone toggles the address bar display
			protected function topOfPhone_clickHandler(event:MouseEvent):void
			{
				if (iPhoneMode())
				{
					if (imgAddressBar.alpha == 0)
						showAddressBar();
					else
						hideAddressBar();	
					
				}
			
			}

			private function Mac():Boolean
			{
				if (Capabilities.os.indexOf("Mac") != -1)
					return(true);
				else
					return(false);
				
			}
			
			private function Windows():Boolean
			{
				if (Capabilities.os.indexOf("Windows") != -1)
					return(true);
				else
					return(false);
				
			}
	
			// Attempt to strip flash content
			// Experimental!
			private function sanitize():void
			{
				//return;
				
				if (_supportFlash)
					return;
				
				// Wrapping it all in big try catch to try and be as robsut as possible
				try 
				{
					
					var loader:HTMLLoader;
					loader = _host.getHTMLLoader();
					
					for (var tags:int = 1; tags < 3; tags++)
					{	
						var startEl:Object;
						
						var whichTag:String;
						if (tags == 1)
							whichTag = "object";
						else
							whichTag = "embed";
						
						startEl = loader.window.document.getElementsByTagName(whichTag);
						
						if (startEl)
						{
							
							for (var i:int = 0; i < startEl.length; i++)
							{
								
								var s:String = startEl[i].innerHTML;
								//trace("possible flash content = " + s);
								s.toLowerCase();
								
								// If we find Flash, attempt to hide it
								if (s.indexOf(".swf") != -1)
								{
									startEl[i].style.visibility = "hidden";
									startEl[i].innerHTML = "";
									
									continue;
								}
								
								// Depending on how stuff was embedded?
								var s2:String;
								s2 = startEl[i].outerHTML;
								s2.toLowerCase();
								trace(s2);
								
								if (s2.indexOf(".swf") != -1)
								{
								
									startEl[i].outerHTML = "";
									startEl[i].style.visibility = "hidden";
									
								}	
							}
						}
					}
				}
				catch (errObject:Error) 
				{
					trace(errObject.message);
					return;
				}	
			}
			
		]]>
	</fx:Script>
	
	
</mx:WindowedApplication>
